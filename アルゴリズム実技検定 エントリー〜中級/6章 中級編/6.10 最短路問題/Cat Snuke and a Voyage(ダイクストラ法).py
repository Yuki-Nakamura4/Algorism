# ダイクストラ法

# 幅優先探索の場合、キューの先頭から取り出される頂点は、
# キューに含まれている頂点の中で最も始点からの距離が小さいことが保証されている

# しかし、ダイクストラ法の場合はキューを使うと取り出される頂点の距離が必ずしも最小ではなくなる
# そのため、ダイクストラ法ではキューを使わず代わりにヒープを用いる。

import heapq

N, M = map(int, input().split())

# グラフは隣接リストで表現する
# 隣接リストとは、各頂点に対して、その頂点に隣接する頂点のリストを持たせる表現方法
# 今回はN個の頂点を持つグラフなので、N個の空のリストを用意する
G = []
for _ in range(N):
    G.append([])

# グラフの辺を受け取る
for _ in range(M):
    ai, bi = map(int, input().split())

    # 頂点番号は-1にして0から始まるようにする
    ai -= 1
    bi -= 1

    # aiとbiの間に辺を張る
    G[ai].append(bi)
    G[bi].append(ai)

####################################################
# ダイクストラ法で各頂点への最短距離を求める
####################################################

# 頂点0から各頂点への最短距離を格納する配列
# N個の-1で満たしておく(-1は未訪問であることを表す)
dist = []
for _ in range(0, N):
    dist.append(-1)

# ダイクストラ法で使うヒープ
Q = []

# 始点となる頂点0をヒープに追加しておく
# (距離, 頂点)として追加する
heapq.heappush(Q, (0, 0))

# 始点となる頂点0への最短距離は0とする
dist[0] = 0

# ダイクストラ法で各頂点への最短距離を求める
while len(Q) > 0:
    # ヒープの先頭の頂点を取り出してiとする
    d, i = heapq.heappop(Q)

    # 頂点iに隣接する頂点を順番に見る
    # 見ている頂点をjとする
    for j in G[i]:
        # この問題では、辺の重みは常に1
        x = 1

        # jが未訪問だったとき、あるいはjへの最短距離が更新可能だったとき
        # jへの最短距離を更新して、ヒープの末尾に追加する
        # (幅優先探索と違って、辺の重みによって最短距離が変わることがある)
        if dist[j] == -1 or dist[j] > dist[i] + x:
            dist[j] = dist[i] + x
            # (距離, 頂点)としてヒープに追加する
            # 距離の小さい順に取り出されるため、距離を先に書く
            heapq.heappush(Q, (dist[j], j))

if dist[N - 1] == 2:
    print("POSSIBLE")
else:
    print("IMPOSSIBLE")
